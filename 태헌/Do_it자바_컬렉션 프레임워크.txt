자료구조 
Array 배열 : 같은 형의 데이터 타입을 메모리에 저장하는 선형적 자료구조 >> 일렬로 되어있음
	논리적구조와 물리적 구조가 동일 
	fixed-length 정해진 길이로 배열을 생성
	인덱스연산이 잘 이루어짐. >
LinkedList : 물리적위치와 논리적위치 동일하지않음.
	 필요할때마다 다음 노드의 주소를 가리켜서, 연결 >> 배열의 요소가 계속 변함, 
	배열의 요소가 유동적일때 사용.
	i번쨰 위치를 찾는데 무조건 앞에서부터 찾아야함.
Stack  	: 후입선출  
	push pop          peek 스택의 맨위에 있는 원소를 반환( 제거X)
	쌓다. 
Queue	: 선입선출
	<--     front      rear    <--

Tree : Binary Search Tree ( 자식 노드의 수가 최대 2개인 트리) : 
1. 유일한 키값
2. 루트 노드의 키 값 기준
나를 중심으로 왼쪽의 자식노드는 나보다 작아야하고 오른쪽은 큰 값이어야함 
중복 허용X , 어떻게 insert 되느냐에 따라 트리 모양이 달라질 수 있음.

>> 균형이 맞을 수록 검색 속도가 log2 n에 가까워짐

트리를 도는 방법. 3가지
in-order : 나를 중심으로 레프트->나->라이트 >> 오름차순으로 정렬이됨.
pre-order : 
post-order 

hashing 해싱 : 검색을 위한 자료구조로 산술 연산을 이용한 검색을 함.
 	키값%해시펑션 , 중복된위치가 발생할 경우 옆자리? 에 배치 


컬렉션 프레임 워크 : 
다수의 데이터를 쉽고 효과적으로 처리할 수 있는 표준화된 방법을 제공하는 클래스의 집합을 의미
--> 데이터를 저장하는 자료 구조와 데이터를 처리하는 알고리즘을 구조화하여 클래스
프로그램 구현에 필요한 자료구조를 구현해 놓은 라이브러리 .java.util 패키지에 구현되어있음.
	-개발에 소요되는 시간 절약가능. 최적화된 알고리즘 사용가능
	-여러 인터페이스와 구현클래스 사용방법을 이해해야함.

collection 계열 : 하나의 데이터만 핸들링 , 하나의 객체를 관리하기 위한 메서드가 정의된 인터페이스.
1. List 인터페이스 :선형자료구조, 순서 존재, 중복허용
	ArrayList 		Stack	Queue
	Vector : 멀티 쓰레드 상태에서 리소스에 대한 동기화가 필요한경우 사용 
	LinkedList
2. Set 인터페이스 : 집합, 중복허용X, 순서상관X
	HashSet 키값에 따라 특정한 인덱스 할당받음. , get()메서드 제공X ->
	TreeSet : 객체의 정렬에 사용되는 클래스. (내부적으로 이진검색트리로구현),
		 -객체 비교를 위해 Comparable Comparator 인터페이스를 구현 (implements)
Map계열
3. Map 인터페이스 : 쌍으로 된 데이터 핸들링 , 키값은 중복X 밸류값은 중복가능
	Hashtable : 동기화 지원
	HashMap: 동기화 지원X 
	TreeMap :
	Properties :저장된 파일을 읽어서 Key:value 페어로 메모리상에 둠.

Iterator: 모든 요소를 처음부터 끝까지 순회

Comparable 인터페이스 : compareTo() 메서드를 구현 , 매개변수와 객체 자신(this)을 비교
Comparator 인터페이스 : compare() 메서드를 구현 , 두개의 매개 변수를 비교
정렬 대상이 되는 클래스가 구현해야하는 인터페이스
comparable을 더 많이 사용. 이미 comparable이 구현된 경우 comparator을 이용해 다른 정렬 방식을 정의 가능.

Map 인터페이스 : key-value pair의 객체관리, key는 중복불가 , 검색을 위한 자료구조
	내부적으로 hash방식으로 구현 
	key객체의 유일성 여부를 판단하기위해 equals() 와 hashCode() 메서드를 재정의함
