자바를 쓰면 좋은 이유
1. 객체 지향 언어이기 떄문에 유지 보수가 쉽고 확장성이 좋음
2. 프로그램이 안정적
3. 풍부한 기능을 제공하는 오픈 소스

플랫폼에 영향을 받지 않고 다양한 환경에서 사용가능 
	ex) jvm을 통해서 윈도우,리눅스 환경에서 별다른 컴파일없이 기존 파일 사용
		jvm이 설치되어있다면 한번 컴파일된 파일이 여러 환경에서 실행 가능

패키지 생성후 안에 src 생성
-----------------------------------------------------------------------------------------------
변수 및 자료형 

16진수 1글자 표현하는데 4비트 필요,

64비트를 16진수로 표현하면 16자리 필요
32비트를 16진수로 표현하면 자리 필요

뒤에나올 숫자 
0B 2진수
0 8진수
0X 16진수

int num = 10;
int bNum = 0B1010; // 2진수에서의 10
int oNum =012; 8진수에서의 10
int hNum =0XA;

System.out.printin()  //  자바 출력문 

MSB : 맨앞에 존재하는 부호비트 , 0이면 양수 1이면 음수
음수를 만드는 방법 : 2의 보수를 취한다. 
음의 정수 표현법  : 해당 수의 보수를 취한후 1을 더한다.
-----------------------------------------------------------------------------------------------
메모리 : 프로그램에서 사용되는 자료를 저장하는 공간
변수( variable ) : 할당 받은 메모리의 주소 대신 부르는 이름 , 프로그램 실행 중에 값 변경 가능 , 사용 이전에 선언되어야함 

Lvalue =Rvalue  Rvalue를 Lvalue에 대입한다.

변수 선언시 유의점 >>>>>>>>>>>> 역할에 어울리는 의미있는 변수명 사용
- 변수명은 알파벳, 숫자,_ , $ 로 구성
- 대소문자 구분
- 숫자로 시작 X , 키워드도 변수명 사용 불가
- 이름 사이에 공백 X
-----------------------------------------------------------------------------------------------
자료형
변수가 사용할 공간의 크기와 특성에 따라 자료형을 사용하여 변수 선언
	정수형 	문자형 	실수형	논리형
1바이트	byte			boolean
2바이트	short	char	
4바이트	int		float
8바이트	long		double

정수형
int :  
-4byte단위의 자료형 , 
-자바에서사용하는 정수에 대한 기본 자료형
- 32비트를 초과하는 수는 long 형으로 처리
long :
- 8바이트 자료형 , 가장 큰 정수 자료 형
- 숫자의 뒤에 L 또는 l 를 써서 long 형임을 표시해야만함

문자형
char :  자바에서 2바이트로 처리 
인코딩 - 문자에 따른 특정한 숫자 값을 부여
디코딩 - 숫자 값을 원래 문자로 변환 

문자세트 : 문자를 위한 코드값들을 정해놓은 세트
아스키 1바이트로 영문사 숫자 특수문자등을 표현
유니코드 한글과 같은 복잡한 언어를 표현하기 위한 표준 인코딩

char ch
문자형은 내부적으로 정수로 표현 


float (4바이트), double (8바이트) : 실수 자료형
실수는 기본적으로 long으로 처리함
float형으로 사용하는 경우 숫자에 식별자 f,F를 명시

float	부호비트+ 지수부( 8비트)+가수부( 23비트)
double	부호비트+ 지수부( 11비트)+가수부( 52비트)

double dNum = 3.14;
float fNum = 3.14f;

boolean - 논리형
true false

자료형 없이 변수 사용하기 (자바10)
자료형이 필요한 이유 : 변수를 선언 할 때는 변수가 사용할 메모리 크기와 타입을 구분하기 위해 자료형을 사용
지역 변수 자료형 추론 : 변수에 대입되는 값을 보고 컴파일러가 추론 
-----------------------------------------------------------------------------------
상수 : 변하지 않는 값 , 관용적으로 상수는 대문자로 표현
- final 키워드 사용 ex) final double PI =3.14;
- final 로 선언도니 상수는 다른 값을 대입 불가 ->> 대입시 에러발생
프로그램 내에서 

리터럴 literal  : 프로그램에서 사용하는 모든 숫자 , 값 , 논리 값 ex) 10, 3.14 , 'A' , True
-특정 메모리 공간인 상수 풀 (constant pool)에 리터럴값 존재
- 상수 풀에 저장 할떄, 정수는 int 실수는 double로 저장. 이외로 저장할떄는 식별자 지정해야함
 
형 변환 ( type conversion )
- 자료형은 각각 사용하는 메모리 크기와 방식이 다름
- 서로 다른 자료형의 값 대입시 형 변환이 일어남.
- 묵시적 형변환 implicit Conversion : 작은 수에서 큰 수로( byte > short > int > long ) , 덜 정밀한 수에서 더 정밀한 수로 대입되는 경우 (정수 -> 실수 )

- 명시적 형 변환 : 묵시적 형 변환의 반대의 경우 ,
	 변환 되는 자료 형을 명시해야 함, 자료의 손실이 발생 할 수 있음 ex) 3.14 >> int (3.14)

-----------------------------------------------------------------------------------------
 3장 자바 연산자 

항 operand : 연산에 사용되는 값
연산자 operator : 항을 이용하여 연산하는 기호

	항의 개수에 따른 연산자 구분
단항 연산자	
이항 연산자	
삼항 연산자	

대입 연산자 asignment   :  변수에 값을 대입하는 연산자, 연산의 결과를 변수에 대입, 우선순위가 가장 낮음
산술연산자 :  + - * / % 
증가 감소 연산자 :   ++  , -- 
	val = ++num //  먼저 num 값이 1 증가한 후 val 변수에 대입
	val = num++ //  val 변수에 기존의 num 값 대입 후 num 값이 1 증가
	val = --num //  먼저 num 값이 1 감소한 후 val 변수에 대입
	val = num-- //  val 변수에 기존의 num 값 대입 후 num 값이 1 감소
관계연산자 :  True False 
논리 연산자 : 관계 연산자와 혼합하여 많이 사용, 연산의 결과가 treu false로 반환.
	&& 논리곱	: 두항이 모두 참인 경우에만 결과 값이 참. 이외는 거짓
	|| 논리합		: 두항 중 하나의 항만 참이면 결과는 모두 참, 모두 거짓일떄만 거짓
	! 부정 		: 단항 연산자.

&& 연산자 사용할떄 앞에값이 false이면 뒤에 값계산은 할필요가없기에  안하고 바로 넘어감

복합 대입 연산자 
+=	두항의 값을 더해서 왼쪽항에 대입
-= 	왼쪽항에서 오른쪽 항을 뺴서 그 값을 왼쪽항에 대입 
*=	두 항의 값을 곱해서 왼쪽 항에 대입
/= 	왼쪽 항을 오른쪽 항으로 나누어 그 몫을 왼쪽학에 대입
%=	왼쪽 항을 오른쪽 항으로 나누어 그 나머지을 왼쪽학에 대입

조건 연산자
-삼항 연산자 , 조건 식의 결과가 true 와 false 인 경우에 따라 다른식이나 결과가 수행
-제어문 중 조건문을간단히 표견할때 사용할 수 있음
조건식 ? 결과1 : 결과2	조건이 참이면 결과1 거짓이면 결과2 
ex) int num=( 5 < 3)? 10 : 20;

비트 연산자 : 정수에만 사용할 수있다.
~	비트의 반전 ( 1의 보수)
&	비트 단위 AND	1&1 1반환 그외는 0
|	비트 단위 OR	0|0 0반환 그외에는 1
^	비트 단위XOR	두개의 비트가 서로 다른 경우에 1 반환
<<	왼쪽 shift		a<<2 변수a를 2비트만큼 왼쪽으로 이동
>>	오른쪽 shift	a>>2 변수 a를 2비트만큼 오른쪽으로 이동 ( 부호비트가 1이면 1로 0이면 0으로 채워짐)
>>>	오른쪽 shift	>> 동일한 연산 , 채워지는 비트가 부호와 상관없이 0임

복합 대입 비트 연산자 
<<= 비트를 왼쪽으로 이동하고 그 값을 왼쪽 항에 대입   ex) num1 <<=2;  num1=num1<<2하고 같음

연산자 우선순위
1.	일차식 () []
2.	단항 ! ++ -- + -
3.	산술 % /
4.	산술 + -
5.	비트이동 << >>
6.	관계 < > <= >=
7.	관계 == !=
8.	비트 곱 &
9.	비트 차 ^
10.	비트 합 |
11.	논리 곱 &&
12.	논리 합 ||
13.	조건 ? : 
14.	대입 = += -= *= %= /=

---------------------------------------------------------------
4장 제어 흐름 이해하기 
제어문 : 프로그램의 흐름 컨트롤 

조건문 : 주어진 조건에 따라 다른 수행문이 실행되도록 프로그래밍
if문
if ( 조건식 ){
	수행문;
}조건이 참이면 수행문을 실행.

if-else문
if ( 조건식 ){
	수행문1;
}else{
	수행문2;
}참이면 수행문1 실행 아니면 수행문 2 실행

switch-case 문 :
	조건식의 결과가 정수 또는 문자열의 값이고 그 값에 따라 수행문이 결정될때
	if-else 문을 대신해 switch-case 문을 사용
break를 사용해서 switch-case문을 빠져나옴
switch(조건){
	case 1: 수행문 ;
		break;
	case 2: ~~;
		break;
	default : 수행문;
}
case 문에 문자열 사용하기 : 자바 7부터 사용가능 

반복문 : 주어진 조건이 만족 할 떄까지 수행문을 반복적으로 수행
while , do-while, for 
조건의 만족과 반복 가능 여부에 대해 정확한 코딩이 필요 

while( 조건식){
	수행문1;
}수행문2; 
조건식이 참인 동안  수행문 1 수행, 거짓일시 수행문 2로 넘어감

while 문은 처음 시작할 때 조건이 맞지 않으면 시작하지 않음.

do-while 문 :  무조건 1번은 수행문 실행하고 조건에 맞는지 확인하고 반복
do {
	수행
}while( 조건 );

for 문 : 반복문 중 가장 많이 사용하는 반복문 , 주로 조건이 횟수인 경우
for(1.초기화식;2.조건식;4.증감식){
	3.수행문;
} 1 > 2> 3> 4> 2> 3> 4> 순으로 진행

중첩된 반복문 

continue 문 : 반복문과 함께 쓰이며 반복문 내부에 continue문을 만나면 이후 반복되는 부분을 수행하지 않고 조건식이나 증감식을 수행함.
조건이 만족하게 되면 나머지 수행문 실행 안하고 증감문을 바로 넘어감
break  문 : 반복문에서 break 문을 만나면 더이상 반복을 수행하지 않고 반복문을 빠져나옴 , 중복된 반복문 내부에 있는 경우 가장 가까운 반복문 하나만 빠져나옴
